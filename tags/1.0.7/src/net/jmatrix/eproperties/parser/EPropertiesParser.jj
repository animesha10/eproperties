options
{
    LOOKAHEAD=2;
    FORCE_LA_CHECK = true; 
    STATIC=false;
    //DEBUG_PARSER=true;
    //DEBUG_LOOKAHEAD=true;
    //DEBUG_TOKEN_MANAGER=true;
}

PARSER_BEGIN(EPropertiesParser)

// https://javacc.dev.java.net/doc/javaccgrm.html

package net.jmatrix.eproperties.parser;

import java.io.*;
import java.util.*;
import java.net.URL;
import net.jmatrix.eproperties.*;
import net.jmatrix.eproperties.include.*;
import org.apache.commons.logging.*;

/**
 * This class is generated by JavaCC.  DO NOT MODIFY THIS SOURCE as 
 * a .java file - only modify the .jj file and re-generate with JavaCC.
 */
public class EPropertiesParser {
   static Log log=LogFactory.getLog(EPropertiesParser.class);
   
    StringBuilder commentBuffer=new StringBuilder();
    
    EPropertiesIncluder includer=new EPropertiesIncluder();
    
    int depth=0;
    String currentKey=null; // can be null;
    URL sourceURL=null; // can be null
    
    /** */
    public EPropertiesParser(String s) 
    {
        this((Reader)(new StringReader(s))); 
    }
    
    /** */
    public void setSourceURL(URL u) {
       sourceURL=u; // THIS CAN BE NULL!!!
    }
    
    /** */
    EProperties parse() throws ParseException {
        return parse(null);
    }
    
    /** */
    Object processInclude(EProperties parent, String url) {
        log.debug("INCLUDE: url='"+url+"'");

        //EProperties props=includer.processInclude(parent, url);
        Object result=includer.processInclude(parent, url);
        
        return result;
    }
    
    /** */
    private final String indent() {
       StringBuilder sb=new StringBuilder();
       for (int i=0; i<depth; i++) {
          sb.append("  ");
       }
       return sb.toString();
    }
}
PARSER_END(EPropertiesParser) 

/**  And now, the actual parsing specifications...... */

<DEFAULT>
/** Skip these characters, they are considered "white space" **/
SKIP :
{
    " "
    | "\t"
    | "\r"
    | "\n"
}


TOKEN: 
{
//      <LPAREN: "("> : LIST_STATE
//   |  <RPAREN: ")">
     <EQUALS: "="> : VALUE_STATE
//   |  <LBRACE: "{">
//   |  <RBRACE: "}"> 
//   | <ROOT_LBRACKET: "[">  : INCLUDE_STATE 
//   | <HASH: "#"> : COMMENT_STATE
   | <RBRACE: "}">
   
   
//   |  <LBRACKET: "]"
//   |  <COMMA: ",">
//   |  <LT: "<">
//   |  <GT: ">">
}

TOKEN : /* the keywords and comparators - QUOTEDVALUE accounts for escaped quotes as well */
{
     < KEY_STRING : (["A"-"Z","a"-"z","0"-"9", ".", "_", "-", "/", "%"])+ >
     | <COMMENT: "#"  (~["\r", "\n"])* ("\n"| "\r" | "\r\n")? > : DEFAULT
     | <INCLUDE_URL: "["  (~["\r", "\n", "]"])* ("]") > : DEFAULT
//    |   < QUOTED_STRING: "\"" (~["\""] | "\\\"")* "\"" > 
     
     
     /* Working quoted string, without quote escaping */
     /* < QUOTED_STRING: "\"" (~["\""])* "\"" > */
}

//MORE : 
//{
//   //"#" : COMMENT_STATE |
//   //"[" : INCLUDE_STATE
//}

//<COMMENT_STATE>
//TOKEN:
//{
//    <COMMENT: "\n"> : DEFAULT
//}
//
//<COMMENT_STATE>
//MORE: 
//{
//   < ~[] > 
//}

//<INCLUDE_STATE>
//TOKEN:
//{
//    <INCLUDE_URL: "]"> : DEFAULT
//}
//
//<INCLUDE_STATE>
//MORE:
//{
//    //<(["A"-"Z","a"-"z","0"-"9", ".", "_", "-", "/", "%", ":","$", "{", "}", "(", ")", ">"])+ >
//   <(~["]"])+ >
//}

<VALUE_STATE>
SKIP:
{
   " " | "\t"
}

<VALUE_STATE>
TOKEN: 
{
     <LPAREN: "("> : LIST_STATE
   | <LBRACE: "{"> : DEFAULT
   | <VALUE_INCLUDE_URL: "["  (~["\r", "\n", "]"])* ("]") > : DEFAULT
}

//<VALUE_STATE>
//MORE:
//{
//   "[" : INCLUDE_STATE
//}

<VALUE_STATE>
TOKEN: 
{
     <QUOTED_STRING: "\"" (~["\""] | "\\\"")* "\"" > : DEFAULT 
   | <EOL_STRING: ~["(", "[", "{", " "] (~["\r", "\n"])* ("\n"| "\r" | "\r\n")? > : DEFAULT
   
   // Important - I was getting errors when files ended with key=value<EOF>
   // The fix is in EOL_STRING above - adding the trailing regex (0-1) times 
   // with the '?'.  
   // this does not work:
   //    ... ("\n"| "\r" | "\r\n") > : DEFAULT
   // this does:
   //    ... ("\n"| "\r" | "\r\n")? > : DEFAULT
}

<LIST_STATE>
SKIP:
{
   " "
   | "\t"
   | "\r"
   | "\n"
}

<LIST_STATE>
TOKEN: 
{
   <RPAREN: ")"> : DEFAULT
}
<LIST_STATE>
TOKEN: 
{
   <COMMA: ","> |
   <LIST_QUOTED_STRING: "\"" (~["\""] | "\\\"")* "\"" > |
   <LIST_COMMENT: "#"  (~["\r", "\n"])* ("\n"| "\r" | "\r\n")? > 
}

/** 
 *  Top level
 */
EProperties parse(EProperties p) :
{
    if (p == null)
       p=new EProperties();
}
{
    p=eproperties(p, null)   <EOF> 
    {
       return p;
    }
}

/**  */
EProperties eproperties(EProperties p, EProperties par) :
{
    if (p == null)
        p=new EProperties(par);
        
    depth++;
    String slog=indent()+"SURL: "+sourceURL+"\n"+
        indent()+"Starting properties ("+currentKey+") at depth "+depth;
    log.debug(slog);
    
    Key key=null;
    List<String> list=null;
    String value=null;
    Token tComment=null;
    Token tok=null;
    EProperties props=null;
    Object includeResult=null;
}
{     (
        tComment=<COMMENT> {
           log.trace("Found comment line '"+tComment.image+"'");
           commentBuffer.append(tComment.image); // this contains \n
        } 
        
        | 
        
        (key=key() <EQUALS> 
         [tok=<VALUE_INCLUDE_URL> {
            includeResult=processInclude(p, tok.image);
            if (includeResult != null) {
               // includeResult should be [String, List<String>, EProperties]
                //props.setParent(p, key);
                // parent will be set by EPropertiesIncluder.
                p.put(key, includeResult);
            }
         }| 
          <LPAREN> list=list() {p.put(key, list);} <RPAREN> | 
          <LBRACE> props=eproperties(null, p) {
             p.put(key, props);
          }<RBRACE> |
          value=value() {p.put(key, value);} ]
        )
        |
        tok=<INCLUDE_URL> {
           log.debug("RootInclude: token="+tok);
           includeResult=processInclude(p, tok.image);
           if (includeResult != null) {
              
              if (includeResult instanceof EProperties) {
                 p.merge((EProperties)includeResult);
              } else {
                 log.error("RootInclude: includeResult cannot be instance of "+
                       includeResult.getClass().getName());
              }
           } else {
              // this was logged at error, but now we have a flag that
              // can say: 'fail.on.error=false' - meaning this is a
              // really non-critical type error. 
              log.info("RootInclude: includeResult is null for token "+tok);
           }
        }
      )+ 
       {
   slog=indent()+"Returning from Nested Properties at depth "+depth+"\n"+
        indent()+"At source URL "+sourceURL+"\n"+
        indent()+"Token "+token.image.trim()+" at "+token.beginLine+":"+
                 token.beginColumn+" - "+token.endLine+":"+token.endColumn+
                " Token.kind["+token.kind+"]: '"+tokenImage[token.kind]+"'";
   log.debug(slog);
   
   depth--;
   return p;}   
}


/** */
Key key() :
{
    Token tKey;
    String sKey;
}
{
     tKey=<KEY_STRING> {
         sKey=tKey.image;
         
         log.trace("Key defined, key string '"+sKey+"'");
         log.trace("  comments: "+commentBuffer.toString());
         
         Key key=new Key(sKey, commentBuffer.toString());
         commentBuffer.delete(0, commentBuffer.length());
         currentKey=sKey;
         return key;
     }
}

/** */
String value() :
{
    Token tValue;
    String sValue;
}
{
     tValue=<QUOTED_STRING> {
         //System.out.println ("value="+tValue.image);
         String s=tValue.image;
         
         log.trace("QUOTED_STRING, RAW: \n"+s);
         
         s= s.substring(1, s.length()-1); // strip quotes
         
         // quoted strings can contain escaped quotes.  They
         // will be un-escaped here.  <String> cannot contain
         // quotes - escaped or not, as the parser will not allow it.
         
         // Fred - I'm reverting back to the original rule.  That is
         // inside a quoted string, the only thing that needs to be escaped
         // is the double quote iteslf.
         // for NON quoted strings (ala standard properties), your rule 
         // takes hold.   (see below on escaping rule for EOL String.
         //s=s.replaceAll("\\\\(.)", "$1");
         log.trace("QUOTED_STRING, Applying escaping rules for quoted eol string.");
         s=s.replace("\\\"", "\"");
         return s;
     }
     |
     tValue=<EOL_STRING> {
         //System.out.println ("value="+tValue.image);
        String s=tValue.image;
        log.trace("EOL_STRING, RAW: \n"+s);
        
        // strip the '\n'. EOL_STRING will _normally_ end with \n, but not
        // if it encounters an <EOF>
        if (s.endsWith("\r\n")) 
           s=s.substring(0, s.length() -2); 
        if (s.endsWith("\n") || s.endsWith("\r"))
           s=s.substring(0, s.length() -1);
        
        
        if (s.startsWith("\"") && s.endsWith("\"")) {
           log.trace("EOL_STRING, Applying escaping rules for quoted eol string.");
           s= s.substring(1, s.length()-1); // strip quotes
           s=s.replace("\\\"", "\"");  // un-escape internal quotes.
        } else {
           log.trace("EOL_STRING, Applying escaping rules for NON-quoted eol string.");
           // apply standard escaping for non-quoted strings
           s=s.replaceAll("\\\\(.)", "$1");
        }
        
         return s;
     }
}

/** */
List<String> list() :
{
   List<String> values=new ArrayList<String>();
   Token tValue;
}
{
    (tValue=<LIST_QUOTED_STRING>{
        String s=tValue.image;
        s=s.replace("\\\"", "\"");
        values.add(s.substring(1, s.length()-1)); // strip quotes
    }<COMMA> | <LIST_COMMENT>)* 
    (tValue=<LIST_QUOTED_STRING>{
        String s=tValue.image;
        s=s.substring(1, s.length()-1);
        s=s.replace("\\\"", "\"");
        values.add(s); // strip quotes
    })? 
    {
        return values;
    }
}


